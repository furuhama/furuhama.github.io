---
layout: post
title: なぜテストを書くのか
date: 2018-05-14 00:00:00
tag: [test, poem]
---

この前 `テストを書くこと` についていい話を聞いたので、聞いた内容を踏まえつつ僕がその時に思ったことを書いてみる。

---

## 前提として (アウトプットのおはなし)

そもそもソフトウェアエンジニアリングに限らず、世の中において広くアウトプットを出していくという行動を行う上で、

- 現実(実態)
- 意図
- アウトプット

の 3 つの世界が存在している。

### 現実 の世界

`現実` とは、客観的な視点がこの世に存在すると仮定して、彼が見ているこの世界のことだ。

### 意図 の世界

`意図` とは、現実を我々が我々なりになるべく客観的に見た上で、そこに対してアウトプットを行って価値を生み出そうとしたときの、価値を生み出そうと判断した理由や、どんな価値を生み出そうと思ったのか、という思考の道筋のことだ。

ソフトウェア開発においては特に、経営サイドによるビジネス的な判断やサービス仕様と置き換えられるものだと思う。

### アウトプット の世界

`アウトプット` とは、上の 2 つの世界で起きたことを踏まえて、実際に生み出されるアウトプットのことだ。

それはコードであり、アプリケーション自身であり、サーバーであり、デバイスであり、ユーザーの経験である。

--

これら 3 つの世界が噛み合っているうちは、各世界は綺麗に回り続けると考えられるけれども、3 つの世界がズレ始めた時にそれぞれの世界で不幸なことが起き始めると僕は考えている。

話が大きくなりすぎるとこの先大変そうなので、ソフトウェアエンジニアリングの世界に絞って話を進めたい。

ソフトウェアエンジニアリングにおいて、エンジニアが日々生活し格闘するのは、主に上で挙げたうちの 3 つめの世界、すなわち `アウトプットの世界` だろうと思う。

だけどここまで話してきたように、アウトプットの世界の住民は、現実の世界と意図の世界にも気を配り続けなくちゃいけないと考えている。

--

## とある和訳記事風の例え話

僕はあるアプリケーションを日々開発している。

ある日、同僚の営業の人から「これバグなんだけど」というエンジニアが最も忌むべき枕詞と共に、彼がそのアプリケーションに対して意図していなかった挙動について報告をしてきた。

彼から話を聞くと、どうやら僕たちがアプリケーションの挙動を決めた際に前提としていた状況が間違っていたようだ。

僕は何人かの同僚と会話を進めて、仕様を再設計し、実装を行った。

## とある和訳記事風の例え話 (あるいは同僚との日常)

次の日、 github で同僚の書いたコードのレビューをしていると、同僚がどう考えてもおかしいコードを書いていることに気づいた。

彼にそのことを指摘するコメントをすると、すぐに返事が返ってきた。

「そんなはずない、ここはこれでいいはずだ。月次ミーティングのメモをちゃんと参照してコードを書いたんだ。」

(なんだって？あのあと確か先週のミーティングで新たな要望が加わって、ロジックが変わったはずだ。)

僕はそのことを彼とコメントでやり取りするうちに、彼はそのことを思い出したようで

謝りの言葉と共に正しい実装を push し直し、僕は出来上がった素晴らしいコードに気の利いた猫の lgtm 画像を送った。(だって猫は可愛いだろう？)

## とある和訳記事風の例え話 (あるいは上司との闘争)

週末、僕は上司に呼ばれて会議室に出向いた。

聞くところによると上司は 2 週間後に大きな新機能をリリースしてほしいと言う。

かなり詳細な部分まで固まった仕様も一緒に投げつけてきた。

僕の考えるところではこの機能は確かに便利に見えるが、細かいケースでの想定が甘く、

最悪の場合ユーザーに大きな迷惑を掛けてしまう。

そんなことが起きたらこのアプリケーションへの信頼度は低下してしまうし、

今までユーザーに届けることのできていた価値を届けられなくなってしまうかもしれない。

僕は上司に、自分の判断の理由を伝え、彼は最終的に納得してくれた。

--

さて、 3 つもよくわからない(くだらない)例え話を書いてしまった。

最初の話は `現実の世界` と `意図・アウトプットの世界` のズレ、

次の話は `アウトプットの世界` と `現実・意図の世界` のズレ、

最後の話は `意図の世界` と `現実・アウトプットの世界` のズレ、を表現したかった。

--

## 僕たちがコードを書いている世界

3 つに分かれた世界においてコードを書くということは、僕たちは自分の住む世界に対してだけじゃなくて、

`3 つ全ての世界に対して誠実に直視する義務があるということ` に他ならないと思っている。

少なくとも自分の担当するアプリケーションの領域において、僕たち以外に誰が(現実・意図の世界だけでなくて)

アウトプットの世界にまで本当の意味で気を配れるだろうか。

--

## 現実の難しさ

しかし 3 つの世界において、現実の世界を誠実に直視することはとっても難しい。

主観・バイアスが絶対に入り込むし、そもそも一人の人間が観測するには広すぎる領域だからだ。

(神様と猫の目以外にこの世の中を見透かしている存在なんていないはずだ。)

--

## だからこそ

だからこそ、僕たちは最低限、`意図の世界` と `アウトプットの世界` のズレがなるべく存在しない状態を保つ責任がある。

この 2 つの世界は現実の世界に比べると、幾分か観測も制御も簡単であることは間違いないからだ。(それでも十分に難しいと思う)

そして、この 2 つの世界を統一する魔法のコンセプトこそが `テスト` である。そんな風に僕は考えている。

つまり、この前提に立って(時に忘れてしまっていても立ち返ってきて)、 3 つの世界に目を向けつつ、どうやって 2 つの世界を繋げるかを考えることが

あるべきテストを考えることなんじゃないのかなあ、と思っている。

--

# より技術的な話もしておこう

## インターフェースの重要性

ソフトウェアエンジニアリングにおいて重要なのは、

`各責務を持った機能たち` を `不整合のないように上手に統べてあげること` だ。

物理的/論理的に、人間が全てに気を配るのには十分に難しすぎる現代の計算機とその上で動くアプリケーション群においては

`抽象化による各機能のグルーピング(レイヤー分割)` は人間に必須な能力だ。

その上で抽象化された機能たちが最後までビー玉を落とさずにピタゴラスイッチさせてあげるためには、

細かいレールの違いよりも、どこでビー玉はジャンプして、どこに着地するのか、

各ギミックのスタートとゴールの整合性が何よりも重要であることは間違いないのだと思う。

(気をつけて欲しいのは、あくまでそれが対象の `十分な複雑さ` によってもたらされる戦略なのであって、

対象から複雑さを上手く取り除いた後は、より `具体` に降りていく必要が出てくるということだ。)

各ギミックのスタートとゴールの整合性を保証してあげることががすなわち、

ソフトウェアエンジニアリングにおける `インターフェースの保証` になるのだと考えている。

--

これは `オブジェクト志向型言語` が生まれた理由でもあるのだと思う。

前のギミックがうまいこと狙ったタイミングでビー玉を放り出してくれさえすれば、

次のギミックは、前のギミックが例えどんな愉快なビー玉転がしを行っていようとも、

例えその中身が撮影寸前に大幅に変更されようとも何も気にする必要はない。

そんな状況を作りたいモチベーションからオブジェクト志向が生まれたであろうことはあながち嘘ではないはずだ。(カプセル化の話)

--

ちょっと余談になってしまうけれども、あるギミックをビー玉が通っている時に、

積み木を落としたり別のビー玉を発射する仕組みがあったとしよう。

さっきは自分の前のギミックが何をやっているか知る必要がない、と言ってしまったけれども

もし積み木が別のギミック内のビー玉の通り道を邪魔したらどうしよう？

あるいはもし別のビー玉が本来のビー玉に当たって、代わりに転がり始めたらどうしよう？

オブジェクト志向で開発を行っているうちに、何人かの人の頭の中にはこんな心配が起こり始めたみたいで、

そこから、副作用のない、参照透明な形で処理をなるべく連ねていくことを目的として

`関数型言語` が生まれたのかなーなんて僕は考えている。

--

話がオブジェクト志向や関数型にふらふらと寄り道してしまったけれども、

ようは `テストにおいて第一に考えるべきなのは各処理のインターフェースの保証` だということを主張したかった。

これによって大きな大きなピタゴラスイッチ的装置も全体として問題なく動くはず、とまずは言えるはずだ。

(インターフェースの保証のためには処理の境界地付近でのテストは入念に行うべきだろう。)

しかもインターフェースを保証するテストを書いていて、テストを書くのが難しい時は、

対象が、人間が扱うには難しすぎるということを暗に教えてくれさえする。

テストによるインターフェースの固定はとっても素晴らしいことと考えて間違いないだろう。

--

## 人は間違える生き物

人は間違える生き物で、それはアプリケーションにおいても同様だ。

ユーザーに価値を届けたいと思って作ったアプリケーションも、時に意図せぬ挙動をユーザーに対して行ってしまうことがある。(最悪だ！)

そんな時に、膨大なユーザーとのインターフェースの中で、最低限一度失敗してしまった部分を保証してあげるのは悪くないアイデアだと思う。

よりテクニカルには、リグレッションテストの形式で E2E テストを行うのは悪くないアイデアみたいだ。

重たいし、挙動も安定しない E2E テストが嫌いな人はたくさんいると思う。( html の描画はとっても大変な処理だ。)

React みたいな Virtual DOM を利用したフレームワークが出てきているとはいえ、

まだ E2E テストは不完全な状態であるのは間違いないところだと思う。(多分ね)

だからこそ、最低限を保証するために E2E テストを行う。

一度不具合の発生したところをテストする。あるいは、サービスの核となる部分をテストする。

そういった判断でユーザーとのインターフェースをテストしてあげるのは悪くない戦略に思える。

(かなりテクニカルな話になるけど、 CI 環境で E2E テストだけ他のテストと別の環境で回し続ける、みたいな開発スピードを落とさないテクニックがあるらしい)

--

# そんなわけで

「これこれこういう理由で我々はテストを書きます。」

--

# おわりに

なんかこう (テストって大事だけどなんで大事なんだっけ？)

っていう疑問がたまーに浮かぶくらいは、その前提の話を僕はよく忘れてしまうなと思ったので、

実際に文字に書き起こすかと思い立ち書きました。

日曜日の夜が暇だったのも相まって謎の翻訳記事仕立てで、

ポールグレアムが書いた風に誤解されたら面白いなと思って

途中からかなり興が乗って筆を進めていました。

まあ、僕のための文章なので、僕がよければいいのです。

(とはいえ根底のコンセプトはみんなで共有しておきたいなあ、なんて高望みをやめられないのであった...。)
